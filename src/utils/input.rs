use super::read::{Beta, Betas, Read};
use crate::{
    trgt::locus::create_chrom_lookup,
    utils::{locus::InputLocus, open_bam_reader, open_vcf_reader, InputSource, Result},
};
use itertools::Itertools;
use rust_htslib::{
    bam::{self, record::Aux, Read as BamRead},
    bcf::{self, record::GenotypeAllele, Read as BcfRead},
    faidx,
};
use std::{collections::HashSet, io::BufRead, str};

#[derive(Debug)]
pub struct Span {
    pub index: usize,
    pub start: usize,
    pub end: usize,
}

pub fn get_alleles(vcf_src: &InputSource, locus: &InputLocus) -> Result<Vec<Vec<u8>>> {
    let mut vcf = open_vcf_reader(vcf_src)?;
    let mut record = vcf.empty_record();
    while let Some(result) = vcf.read(&mut record) {
        result.map_err(|e| e.to_string())?;

        let tr_id = record.info(b"TRID").string().unwrap().unwrap();
        let tr_id = tr_id
            .iter()
            .map(|elem| str::from_utf8(elem).unwrap())
            .join(",");

        if tr_id != locus.id {
            continue;
        }

        let gt = record.genotypes().unwrap().get(0);
        if matches!(
            gt[0],
            GenotypeAllele::UnphasedMissing | GenotypeAllele::PhasedMissing
        ) {
            return Err(format!("Missing genotype for TRID={tr_id}"));
        }

        let alleles = get_allele_seqs(locus, &record);
        return Ok(alleles);
    }
    Err(format!("TRID={} missing", &locus.id))
}

pub fn get_locus<R>(
    catalog_reader: R,
    genome_reader: faidx::Reader,
    tr_id: &str,
    flank_len: usize,
) -> Result<InputLocus>
where
    R: BufRead,
{
    let chrom_lookup = create_chrom_lookup(&genome_reader)?;
    let query = format!("ID={};", tr_id);

    for (line_number, result_line) in catalog_reader.lines().enumerate() {
        let line =
            result_line.map_err(|e| format!("Error at BED line {}: {}", line_number + 1, e))?;
        if line.contains(&query) {
            return InputLocus::new(&genome_reader, &chrom_lookup, &line, flank_len)
                .map_err(|e| format!("Error at BED line {}: {}", line_number + 1, e));
        }
    }
    Err(format!("Unable to find locus {}", tr_id))
}

pub fn get_reads(
    reads_source: &InputSource,
    locus: &InputLocus,
    max_allele_reads: Option<usize>,
) -> Result<Vec<Read>> {
    let mut bam = open_bam_reader(reads_source, 1)?;

    // This assumes that TRGT outputs flanks shorter than 1Kbps in length. We may want
    // to implement a more flexible mechanism for handling flank lengths here and elsewhere.
    let search_radius = 1000;
    let search_start = std::cmp::max(0, locus.region.start as i64 - search_radius as i64) as u32;
    let search_end = locus.region.end + search_radius;
    let extraction_region = (locus.region.contig.as_str(), search_start, search_end);

    if let Err(e) = bam.fetch(extraction_region) {
        return Err(format!(
            "Failed to fetch region {}:{}-{} from BAM file: {}",
            locus.region.contig, search_start, search_end, e
        ));
    }

    let mut seqs = Vec::new();
    let mut read = bam::Record::new();
    while let Some(result) = bam.read(&mut read) {
        result.map_err(|e| e.to_string())?;
        let read_name = std::str::from_utf8(read.qname()).unwrap().to_owned();
        let seq = read.seq().as_bytes().to_vec();

        let trid = match read.aux(b"TR") {
            Ok(Aux::String(value)) => value.to_string(),
            Ok(other) => {
                return Err(format!(
                    "Read '{}' has TR tag with unexpected type: {:?}",
                    read_name, other
                ));
            }
            Err(_) => {
                return Err(format!(
                    "Read '{}' is missing the TR tag. Was this BAM file generated by the latest version of TRGT?", read_name
                ));
            }
        };

        if trid != locus.id {
            continue;
        }

        let meth = parse_meth(&read, &seq)?;

        let allele = match read.aux(b"AL") {
            Ok(Aux::I32(value)) => value,
            Ok(Aux::U8(value)) => value as i32,
            Ok(other) => {
                return Err(format!(
                    "Read '{}' has AL tag with unexpected type: {:?}",
                    read_name, other
                ))
            }
            Err(_) => return Err(format!("Read '{}' is missing the AL tag", read_name)),
        };

        let (left_flank, right_flank) = match read.aux(b"FL") {
            Ok(Aux::ArrayU32(value)) => {
                if value.len() != 2 {
                    return Err(format!(
                        "Read '{}' has malformed FL tag. Expected array of 2 values, found {} values",
                        read_name,
                        value.len()
                    ));
                }
                let vals = value.iter().collect::<Vec<u32>>();
                (vals[0] as usize, vals[1] as usize)
            }
            Ok(other) => {
                return Err(format!(
                    "Read '{}' has FL tag with unexpected type: {:?}",
                    read_name, other
                ));
            }
            Err(_) => return Err(format!("Read '{}' is missing the FL tag", read_name)),
        };

        seqs.push(Read {
            read_name,
            seq,
            left_flank,
            right_flank,
            allele,
            betas: meth,
        });
    }

    let seqs = if let Some(max_reads) = max_allele_reads {
        let unique_alleles: Vec<i32> = seqs
            .iter()
            .map(|x| x.allele)
            .collect::<HashSet<i32>>()
            .into_iter()
            .collect();

        unique_alleles
            .into_iter()
            .map(|allele| {
                let num_allele_reads = seqs.iter().filter(|x| x.allele == allele).count();

                // GS: this only works if spanning.bam is sorted by TR length
                let step = std::cmp::max(1_usize, num_allele_reads / max_reads);
                seqs.clone()
                    .into_iter()
                    .filter(|seq| seq.allele == allele)
                    .step_by(step)
                    .take(max_reads)
                    .collect()
            })
            .concat()
    } else {
        seqs
    };

    if seqs.is_empty() {
        return Err(format!("No reads found for TRID={}", locus.id));
    }

    Ok(seqs)
}

fn get_allele_seqs(locus: &InputLocus, record: &bcf::Record) -> Vec<Vec<u8>> {
    let lf = &locus.left_flank;
    let rf = &locus.right_flank;
    let genotype = record.genotypes().unwrap().get(0);

    let mut indexes: Vec<usize> = genotype
        .iter()
        .filter_map(|allele| allele.index())
        .map(|idx| idx as usize)
        .collect();

    indexes.sort_unstable();

    let mut alleles = indexes.iter().map(|&i| record.alleles()[i]).collect_vec();

    // TRGT outputs the shorter allele first (unless the longer allele is ref). So if the first allele is
    // longer and is alt, the allele ordering must have changed.
    if indexes.len() == 2 && indexes[0] != 0 && alleles[0].len() > alleles[1].len() {
        alleles.swap(0, 1);
    }

    alleles
        .into_iter()
        .map(|allele| {
            let allele_seq = allele.iter().skip(1).copied().collect_vec();
            let mut result = lf.clone();
            result.extend_from_slice(&allele_seq);
            result.extend_from_slice(rf);
            result
        })
        .collect_vec()
}

fn parse_meth(read: &bam::Record, seq: &[u8]) -> Result<Betas> {
    let values: Vec<u8> = match read.aux(b"MC") {
        Ok(Aux::ArrayU8(value)) => {
            if value.is_empty() {
                return Ok(Vec::new());
            }
            value.iter().collect::<Vec<u8>>()
        }
        Ok(other) => {
            let read_name = std::str::from_utf8(read.qname()).unwrap_or("<non-utf8>");
            return Err(format!(
                "Read '{}' has MC tag with unexpected type: {:?}",
                read_name, other
            ));
        }
        Err(_) => return Ok(Vec::new()),
    };

    let mut betas = Vec::new();
    let mut cpg_count = 0;
    for pos in 0..seq.len() {
        let is_cpg = pos + 1 < seq.len() && &seq[pos..pos + 2] == b"CG";
        if is_cpg {
            if cpg_count == values.len() {
                let read_name = std::str::from_utf8(read.qname()).unwrap_or("<non-utf8>");
                return Err(format!("Read '{}' has a malformed MC tag", read_name));
            }
            let level = values[cpg_count] as f64 / 255.0;
            let beta = Beta { pos, value: level };
            betas.push(beta);
            cpg_count += 1;
        }
    }

    let all_cpgs_present = cpg_count == values.len();
    let last_cpg_split = seq.last().unwrap_or(&b'X') == &b'C' && cpg_count + 1 == values.len();

    if !(all_cpgs_present || last_cpg_split) {
        let read_name = std::str::from_utf8(read.qname()).unwrap_or("<non-utf8>");
        return Err(format!("Read '{}' has a malformed MC tag", read_name));
    }

    Ok(betas)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::{locus::InputLocusBuilder, test_util, InputSource};
    use rust_htslib::bcf::record::GenotypeAllele;

    #[test]
    fn test_get_alleles_handles_genotypes() {
        use GenotypeAllele::{Phased, Unphased};

        let locus = InputLocusBuilder::new().build();
        let alleles = [b"A".as_ref(), b"AA".as_ref(), b"AAC".as_ref()];

        #[allow(clippy::type_complexity)]
        let cases: Vec<(&str, Vec<GenotypeAllele>, Vec<&[u8]>)> = vec![
            // (name, genotype, expected_allele_seqs)
            ("0/0", vec![Unphased(0), Unphased(0)], vec![b"LR", b"LR"]),
            ("0/1", vec![Unphased(0), Unphased(1)], vec![b"LR", b"LAR"]),
            ("1/1", vec![Unphased(1), Unphased(1)], vec![b"LAR", b"LAR"]),
            ("1/2", vec![Unphased(1), Unphased(2)], vec![b"LAR", b"LACR"]),
            ("0", vec![Unphased(0)], vec![b"LR"]),
            ("1", vec![Unphased(1)], vec![b"LAR"]),
            ("0|1", vec![Phased(0), Phased(1)], vec![b"LR", b"LAR"]),
            ("1|0", vec![Phased(1), Phased(0)], vec![b"LR", b"LAR"]),
            ("1|2", vec![Phased(1), Phased(2)], vec![b"LAR", b"LACR"]),
            ("2|1", vec![Phased(2), Phased(1)], vec![b"LAR", b"LACR"]),
        ];

        for (name, genotype, expected) in cases {
            let temp_vcf = test_util::write_vcf_with_gt(locus.id.as_bytes(), &alleles, &genotype);
            let vcf_src = InputSource::Local(temp_vcf.path().to_path_buf());
            let result = get_alleles(&vcf_src, &locus).unwrap();
            let expected: Vec<Vec<u8>> = expected.iter().map(|e| e.to_vec()).collect();
            assert_eq!(result, expected, "Failed for genotype {name}");
        }
    }

    #[test]
    fn test_get_alleles_errors_on_phased_missing_gt() {
        let locus = InputLocusBuilder::new().build();
        let alleles = [b"A".as_ref(), b"AA".as_ref()];
        let genotype = [GenotypeAllele::PhasedMissing, GenotypeAllele::PhasedMissing];
        let temp_vcf = test_util::write_vcf_with_gt(locus.id.as_bytes(), &alleles, &genotype);
        let vcf_src = InputSource::Local(temp_vcf.path().to_path_buf());
        let err = get_alleles(&vcf_src, &locus).unwrap_err();
        assert!(err.contains("Missing genotype"));
    }

    #[test]
    fn test_get_alleles_errors_on_unphased_missing_gt() {
        let locus = InputLocusBuilder::new().build();
        let alleles = [b"A".as_ref(), b"AA".as_ref()];
        let genotype = [
            GenotypeAllele::UnphasedMissing,
            GenotypeAllele::UnphasedMissing,
        ];
        let temp_vcf = test_util::write_vcf_with_gt(locus.id.as_bytes(), &alleles, &genotype);
        let vcf_src = InputSource::Local(temp_vcf.path().to_path_buf());
        let err = get_alleles(&vcf_src, &locus).unwrap_err();
        assert!(err.contains("Missing genotype"));
    }

    #[test]
    fn test_get_alleles_errors_on_trid_not_found() {
        let locus = InputLocusBuilder::new().id("nonexistent").build();
        let alleles = [b"A".as_ref(), b"AA".as_ref()];
        let genotype = [GenotypeAllele::Unphased(0), GenotypeAllele::Unphased(1)];
        let temp_vcf = test_util::write_vcf_with_gt(b"other_trid", &alleles, &genotype);
        let vcf_src = InputSource::Local(temp_vcf.path().to_path_buf());
        let err = get_alleles(&vcf_src, &locus).unwrap_err();
        assert!(err.contains("TRID=nonexistent missing"));
    }
}
